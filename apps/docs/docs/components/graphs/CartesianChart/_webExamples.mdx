CartesianChart is a customizable, SVG based component that can be used to display a variety of data in a x/y coordinate space. The underlying logic is handled by D3.

## Basics

[AreaChart](/components/graphs/AreaChart/), [BarChart](/components/graphs/BarChart/), and [LineChart](/components/graphs/LineChart/) are built on top of CartesianChart and have default functionality for your chart.

```jsx live
<VStack gap={2}>
  <AreaChart
    enableScrubbing
    height={{ base: 150, tablet: 200, desktop: 250 }}
    series={[
      {
        id: 'prices',
        data: [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58],
      },
    ]}
    showYAxis
    yAxis={{
      showGrid: true,
    }}
  >
    <Scrubber />
  </AreaChart>
  <BarChart
    enableScrubbing
    height={{ base: 150, tablet: 200, desktop: 250 }}
    series={[
      {
        id: 'prices',
        data: [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58],
      },
    ]}
    showYAxis
    yAxis={{
      showGrid: true,
    }}
  >
    <Scrubber hideOverlay seriesIds={[]} />
  </BarChart>
  <LineChart
    enableScrubbing
    height={{ base: 150, tablet: 200, desktop: 250 }}
    series={[
      {
        id: 'prices',
        data: [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58],
      },
    ]}
    showYAxis
    showArea
    yAxis={{
      showGrid: true,
    }}
  >
    <Scrubber />
  </LineChart>
</VStack>
```

## Series

Series are the data that will be displayed on the chart. Each series must have a defined `id`.

### Series Data

You can pass in an array of numbers or an array of tuples for the `data` prop. Passing in null values is equivalent to no data at that index.

```jsx live
function ForecastedPrice() {
  const ForecastRect = memo(({ startIndex, endIndex }) => {
    const { drawingArea, getXScale } = useCartesianChartContext();

    const xScale = getXScale();

    if (!xScale) return;

    const startX = xScale(startIndex);
    const endX = xScale(endIndex);
    return (
      <rect
        x={startX}
        y={drawingArea.y}
        width={endX - startX}
        height={drawingArea.height}
        fill="var(--color-accentSubtleBlue)"
      />
    );
  });
  return (
    <CartesianChart
      enableScrubbing
      height={{ base: 150, tablet: 200, desktop: 250 }}
      series={[
        {
          id: 'prices',
          data: [10, 22, 29, 45, 98, 45, 22, 52, 54, 60, 64, 68, 72, 76],
          color: 'var(--color-accentBoldBlue)',
        },
        {
          id: 'variance',
          data: [
            null,
            null,
            null,
            null,
            null,
            null,
            null,
            [52, 52],
            [50, 57],
            [52, 63],
            [55, 75],
            [57, 77],
            [59, 79],
            [60, 80],
          ],
          color: 'var(--color-accentBoldBlue)',
        },
      ]}
      yAxis={{
        showGrid: true,
      }}
    >
      <ForecastRect startIndex={7} endIndex={13} />
      <Area seriesId="variance" type="solid" fillOpacity={0.3} />
      <Line seriesId="prices" />
    </CartesianChart>
  );
}
```

### Series Axis IDs

Each series can have a different `yAxisId`, allowing you to compare data from different contexts.

```jsx live
<CartesianChart
  height={{ base: 150, tablet: 200, desktop: 250 }}
  series={[
    {
      id: 'revenue',
      data: [455, 520, 380, 455, 190, 235],
      yAxisId: 'revenue',
      color: 'var(--color-accentBoldYellow)',
    },
    {
      id: 'profit',
      data: [23, 15, 30, 56, 4, 12],
      yAxisId: 'profit',
      color: 'var(--color-fgPositive)',
    },
  ]}
  xAxis={{
    data: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
    scaleType: 'band',
  }}
  yAxis={[
    {
      id: 'revenue',
    },
    {
      id: 'profit',
    },
  ]}
>
  <XAxis showLine showTickMarks />
  <YAxis
    showGrid
    showLine
    showTickMarks
    axisId="revenue"
    position="left"
    requestedTickCount={5}
    tickLabelFormatter={(value) => `$${value}k`}
    width={60}
  />
  <YAxis
    showLine
    showTickMarks
    axisId="profit"
    requestedTickCount={5}
    tickLabelFormatter={(value) => `$${value}k`}
  />
  <BarPlot />
</CartesianChart>
```

### Series Stacks

You can provide a `stackId` to stack series together.

```jsx live
<AreaChart
  enableScrubbing
  height={{ base: 150, tablet: 200, desktop: 250 }}
  series={[
    {
      id: 'pricesA',
      data: [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58],
      stackId: 'prices',
      color: 'var(--color-accentBoldGreen)',
    },
    {
      id: 'pricesB',
      data: [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58],
      stackId: 'prices',
      color: 'var(--color-accentBoldPurple)',
    },
  ]}

  showYAxis
  yAxis={{
    showGrid: true,
  }}
>
  <Scrubber />
</LineChart>
```

## Axes

You can configure your x and y axes with the `xAxis` and `yAxis` props. `xAxis` accepts an object while `yAxis` accepts an object or array.

```jsx live
<CartesianChart
  height={{ base: 150, tablet: 200, desktop: 250 }}
  series={[
    {
      id: 'prices',
      data: [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58],
    },
  ]}
  xAxis={{
    scaleType: 'band',
  }}
  yAxis={{
    domain: { min: 0 },
  }}
>
  <YAxis showLine showTickMarks showGrid />
  <XAxis showLine showTickMarks />
  <BarPlot />
</CartesianChart>
```

For more info, learn about [XAxis](/components/graphs/XAxis/#axis-config) and [YAxis](/components/graphs/YAxis/#axis-config) configuration.

## Inset

You can adjust the inset around the entire chart (outside the axes) with the `inset` prop. This is useful for when you want to have components that are outside of the drawing area of the data but still within the chart svg.

You can also remove the default inset, such as to have a compact line chart.

```jsx live
function Insets() {
  const data = [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58];

const formatPrice = useCallback((dataIndex: number) => {
  const price = data[dataIndex];
  return `$${price.toLocaleString('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;
}, []);

  return (
    <HStack gap={2}>
      <VStack gap={1}>
        <Text font="label1">No inset</Text>
        <LineChart
          height={100}
          inset={0}
          series={[
            {
              id: 'prices',
              data,
            },
          ]}
          yAxis={{ domainLimit: 'strict' }}

          showArea
          style={{ border: '2px solid var(--color-fgPrimary)' }}
        />
      </VStack>
      <VStack gap={1}>
        <Text font="label1">Custom inset</Text>
        <LineChart
          enableScrubbing
          height={100}
          inset={{ left: 10, top: 16, right: 10, bottom: 10 }}
          series={[
            {
              id: 'prices',
              data,
            },
          ]}
          yAxis={{ domainLimit: 'strict' }}

          showArea
          style={{ border: '2px solid var(--color-fgPrimary)' }}
        >
          <Scrubber label={formatPrice} />
        </LineChart>
      </VStack>
      <VStack gap={1}>
        <Text font="label1">Default inset</Text>
        <LineChart
          enableScrubbing
          height={100}
          series={[
            {
              id: 'prices',
              data,
            },
          ]}
          yAxis={{ domainLimit: 'strict' }}

          showArea
          style={{ border: '2px solid var(--color-fgPrimary)' }}
        >
          <Scrubber label={formatPrice} />
        </LineChart>
      </VStack>
    </HStack>
  );
}
```

## Scrubbing

CartesianChart has built-in scrubbing functionality that can be enabled with the `enableScrubbing` prop. This will then enable the usage of `onScrubberPositionChange` to get the current position of the scrubber as the user interacts with the chart.

```jsx live
function Scrubbing() {
  const [scrubIndex, setScrubIndex] = useState(undefined);

  const onScrubberPositionChange = useCallback((index: number | undefined) => {
    setScrubIndex(index);
  }, []);

  return (
    <VStack gap={2}>
    <Text font="label1">Scrubber index: {scrubIndex ?? 'none'}</Text>
      <LineChart
        enableScrubbing
        onScrubberPositionChange={onScrubberPositionChange}
        height={{ base: 150, tablet: 200, desktop: 250 }}
        series={[
          {
            id: 'prices',
            data: [10, 22, 29, 45, 98, 45, 22, 52, 21, 4, 68, 20, 21, 58],
          },
        ]}

        showYAxis
        showArea
        yAxis={{
          showGrid: true,
          width: 32
        }}
        inset={{ right: 0 }}
      >
        <Scrubber />
      </LineChart>
    </VStack>
  );
}
```

## Customization

### Price with Volume

You can showcase the price and volume of an asset over time within one chart.

```jsx live
function PriceWithVolume() {
  const [scrubIndex, setScrubIndex] = useState(null);
  const btcData = btcCandles
    .slice(0, 180)
    .reverse()

  const btcPrices = btcData.map((candle) => parseFloat(candle.close));
  const btcVolumes = btcData.map((candle) => parseFloat(candle.volume));
  const btcDates = btcData.map((candle) => new Date(parseInt(candle.start) * 1000));

  const formatPrice = useCallback((price: number) => {
    return `$${price.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })}`;
  }, []);

  const formatPriceInThousands = useCallback((price: number) => {
    return `$${(price / 1000).toLocaleString('en-US', {
      minimumFractionDigits: 0,
      maximumFractionDigits: 2,
    })}k`;
  }, []);

  const formatVolume = useCallback((volume: number) => {
    return `${(volume / 1000).toFixed(2)}K`;
  }, []);

  const formatDate = useCallback((date: Date) => {
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
    });
  }, []);

  const displayIndex = scrubIndex ?? btcPrices.length - 1;
  const currentPrice = btcPrices[displayIndex];
  const currentVolume = btcVolumes[displayIndex];
  const currentDate = btcDates[displayIndex];
  const priceChange = displayIndex > 0
    ? ((currentPrice - btcPrices[displayIndex - 1]) / btcPrices[displayIndex - 1])
    : 0;

  const accessibilityLabel = useMemo(() => {
    if (scrubIndex === null) return `Current Bitcoin price: ${formatPrice(currentPrice)}, Volume: ${formatVolume(currentVolume)}`;
    return `Bitcoin price at ${formatDate(currentDate)}: ${formatPrice(currentPrice)}, Volume: ${formatVolume(currentVolume)}`;
  }, [scrubIndex, currentPrice, currentVolume, currentDate, formatPrice, formatVolume, formatDate]);

  const ThinSolidLine = memo((props: SolidLineProps) => <SolidLine {...props} strokeWidth={1} />);

  const headerId = useId();

  return (
    <VStack gap={2}>
     <SectionHeader
        id={headerId}
        style={{ padding: 0 }}
        title={<Text font="title1">Bitcoin</Text>}
        balance={<Text font="title2">{formatPrice(currentPrice)}</Text>}
        end={
          <HStack gap={2}>
            <VStack justifyContent="center" alignItems="flex-end">
              <Text font="label1">{formatDate(currentDate)}</Text>
              <Text font="label2">{formatVolume(currentVolume)}</Text>
            </VStack>
            <VStack justifyContent="center">
              <RemoteImage source={assets.btc.imageUrl} size="xl" shape="circle" />
            </VStack>
          </HStack>
        }
      />
      <CartesianChart
        enableScrubbing
        onScrubberPositionChange={setScrubIndex}
        height={250}
        series={[
          {
            id: 'prices',
            data: btcPrices,
            color: assets.btc.color,
            yAxisId: 'price',
          },
          {
            id: 'volume',
            data: btcVolumes,
            color: 'var(--color-fgMuted)',
            yAxisId: 'volume',
          },
        ]}
        style={{ outlineColor: assets.btc.color }}
        xAxis={{ scaleType: 'band', range: ({ min, max }) => ({ min, max: max - 16 }) }}
        yAxis={[
          {
            id: 'price',
            domain: ({ min, max }) => ({ min: min * 0.9, max }),
          },
          {
            id: 'volume',
            range: ({ min, max }) => ({ min: max - 32, max }),
          },
        ]}
        accessibilityLabel={accessibilityLabel}
        aria-labelledby={headerId}
        inset={{ top: 8, left: 8, right: 0, bottom: 0 }}
      >
        <YAxis axisId="price" showGrid tickLabelFormatter={formatPriceInThousands} width={48} GridLineComponent={ThinSolidLine} />
        <BarPlot seriesIds={['volume']} />
        <Line seriesId="prices"  showArea />
        <Scrubber seriesIds={['prices']} />
      </CartesianChart>
    </VStack>
  );
}
```

### Earnings History

You can also create your own type of cartesian chart by using `getSeriesData`, `getXScale`, and `getYScale` directly.

```jsx live
function EarningsHistory() {
  const CirclePlot = memo(({ seriesId, opacity = 1 }: { seriesId: string; opacity?: number }) => {
    const { getSeries, getSeriesData, getXScale, getYScale } = useCartesianChartContext();
    const series = getSeries(seriesId);
    const data = getSeriesData(seriesId);
    const xScale = getXScale();
    const yScale = getYScale(series?.yAxisId);

    if (!xScale || !yScale || !data || !isCategoricalScale(xScale)) return null;

    const yScaleSize = Math.abs(yScale.range()[1] - yScale.range()[0]);

    // Have circle diameter be the smaller of the x scale bandwidth or 10% of the y space available
    const diameter = Math.min(xScale.bandwidth(), yScaleSize / 10);

    return (
      <g>
        {data.map((value, index) => {
          if (value === null || value === undefined) return null;

          // Get x position from band scale - center of the band
          const xPos = xScale(index);
          if (xPos === undefined) return null;

          const centerX = xPos + xScale.bandwidth() / 2;

          // Get y position from value
          const yValue = Array.isArray(value) ? value[1] : value;
          const centerY = yScale(yValue);
          if (centerY === undefined) return null;

          return (
            <circle
              key={`${seriesId}-${index}`}
              cx={centerX}
              cy={centerY}
              fill={series?.color || 'var(--color-fgPrimary)'}
              opacity={opacity}
              r={diameter / 2}
            />
          );
        })}
      </g>
    );
  });

  const quarters = useMemo(() => ['Q1', 'Q2', 'Q3', 'Q4'], []);
  const estimatedEPS = useMemo(() => [1.71, 1.82, 1.93, 2.34], []);
  const actualEPS = useMemo(() => [1.68, 1.83, 2.01, 2.24], []);

  const formatEarningAmount = useCallback((value: number) => {
    return `$${value.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    })}`;
  }, []);

  const surprisePercentage = useCallback(
    (index: number): ChartTextChildren => {
      const percentage = (actualEPS[index] - estimatedEPS[index]) / estimatedEPS[index];
      const percentageString = percentage.toLocaleString('en-US', {
        style: 'percent',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      });

      return (
        <tspan
          style={{
            fill: percentage > 0 ? 'var(--color-fgPositive)' : 'var(--color-fgNegative)',
            fontWeight: 'bold',
          }}
        >
          {percentage > 0 ? '+' : ''}
          {percentageString}
        </tspan>
      );
    },
    [actualEPS, estimatedEPS],
  );

  return (
    <CartesianChart
      animate={false}
      height={250}
      inset={{ top: 32, bottom: 0, left: 0, right: 0 }}
      legend={<Legend justifyContent="flex-end" paddingTop={1} />}
      legendPosition="bottom"
      series={[
        {
          id: 'estimatedEPS',
          label: 'Estimated EPS',
          data: estimatedEPS,
          color: 'var(--color-bgPositive)',
          legendShape: 'circle',
        },
        {
          id: 'actualEPS',
          label: 'Actual EPS',
          data: actualEPS,
          color: 'var(--color-bgPositive)',
          legendShape: 'circle',
        },
      ]}
      xAxis={{ scaleType: 'band', categoryPadding: 0.25 }}
    >
      <YAxis
        showGrid
        position="left"
        requestedTickCount={3}
        tickLabelFormatter={formatEarningAmount}
      />
      <XAxis height={20} tickLabelFormatter={(index) => quarters[index]} />
      <XAxis height={20} tickLabelFormatter={surprisePercentage} />
      <CirclePlot opacity={0.5} seriesId="estimatedEPS" />
      <CirclePlot seriesId="actualEPS" />
    </CartesianChart>
  );
}
```

### Trading Trends

You can have multiple axes with different domains and ranges to showcase different pieces of data over the time time period.

```jsx live
function TradingTrends() {
  const profitData = [34, 24, 28, -4, 8, -16, -3, 12, 24, 18, 20, 28];
  const gains = profitData.map((value) => (value > 0 ? value : 0));
  const losses = profitData.map((value) => (value < 0 ? value : 0));

  const renderProfit = useCallback((value: number) => {
    return `$${value}M`;
  }, []);

  const ThinSolidLine = memo((props: SolidLineProps) => <SolidLine {...props} strokeWidth={1} strokeLinecap="butt" />);
  const ThickSolidLine = memo((props: SolidLineProps) => <SolidLine {...props} strokeWidth={2} strokeLinecap="butt" />);

  return (
    <CartesianChart
      height={250}
      series={[
        { id: 'gains', data: gains, yAxisId: 'profit', color: 'var(--color-bgPositive)', stackId: 'bars' },
        { id: 'losses', data: losses, yAxisId: 'profit', color: 'var(--color-bgNegative)', stackId: 'bars' },
        {
          id: 'revenue',
          data: [128, 118, 122, 116, 120, 114, 118, 122, 126, 130, 134, 138],
          yAxisId: 'revenue',
          color: 'var(--color-fgMuted)',
        },
      ]}
      xAxis={{ scaleType: 'band', data: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }}
      yAxis={[
        { id: 'profit', range: ({ min, max }) => ({ min: min, max: max - 64 }), domain: { min: -40, max: 40 } },
        { id: 'revenue', range: ({ min, max }) => ({ min: max - 64, max }), domain: { min: 100 } },
      ]}
    >
      <YAxis axisId="profit" position="left" showGrid tickLabelFormatter={renderProfit} GridLineComponent={ThinSolidLine} />
      <XAxis />
      <ReferenceLine LineComponent={ThickSolidLine} dataY={0} yAxisId="profit" stroke="rgb(var(--gray15))" />
      <BarPlot seriesIds={['gains', 'losses']} />
      <Line seriesId="revenue"  showArea />
    </CartesianChart>
  );
}
```

## Orientation

By default, CartesianChart uses a horizontal orientation where the X-axis is the category/independent axis and the Y-axis is the value/dependent axis. You can switch to a vertical orientation by setting `orientation="vertical"`, which swaps these roles - the Y-axis becomes the category axis and the X-axis becomes the value axis.

### Horizontal Bars with CartesianChart

When using `orientation="vertical"`, bar charts render horizontally. This is particularly useful for displaying ranked data or categories with long labels.

```jsx live
function HorizontalBarExample() {
  const ThinSolidLine = memo((props: SolidLineProps) => <SolidLine {...props} strokeWidth={1} />);

  return (
    <CartesianChart
      orientation="vertical"
      height={{ base: 250, tablet: 300, desktop: 350 }}
      inset={{ top: 8, bottom: 8, left: 8, right: 8 }}
      series={[
        {
          id: 'revenue',
          data: [182, 156, 143, 128, 112, 98, 85],
          color: 'var(--color-accentBoldBlue)',
        },
      ]}
      xAxis={{
        domain: { min: 0, max: 200 },
        showGrid: true,
        GridLineComponent: ThinSolidLine,
      }}
      yAxis={{
        scaleType: 'band',
        data: ['Bitcoin', 'Ethereum', 'Solana', 'Cardano', 'Polygon', 'Avalanche', 'Chainlink'],
      }}
    >
      <XAxis showLine />
      <YAxis position="left" width={80} />
      <BarPlot />
    </CartesianChart>
  );
}
```

### Horizontal Stacked Bars

Stacking also works with horizontal bars in vertical orientation.

```jsx live
function StackedHorizontalExample() {
  const ThinSolidLine = memo((props: SolidLineProps) => <SolidLine {...props} strokeWidth={1} />);

  return (
    <CartesianChart
      orientation="vertical"
      height={{ base: 280, tablet: 320, desktop: 360 }}
      inset={{ top: 8, bottom: 8, left: 8, right: 8 }}
      series={[
        {
          id: 'buy',
          data: [65, 48, 72, 55, 42],
          color: 'var(--color-fgPositive)',
          stackId: 'orders',
        },
        {
          id: 'sell',
          data: [45, 62, 38, 51, 68],
          color: 'var(--color-fgNegative)',
          stackId: 'orders',
        },
      ]}
      xAxis={{
        domain: { min: 0 },
        showGrid: true,
        GridLineComponent: ThinSolidLine,
        tickLabelFormatter: (value) => `${value}%`,
      }}
      yAxis={{
        scaleType: 'band',
        data: ['Bitcoin', 'Ethereum', 'Solana', 'Cardano', 'Polygon'],
      }}
    >
      <XAxis showLine />
      <YAxis position="left" width={70} />
      <BarPlot />
    </CartesianChart>
  );
}
```

### Multiple Series Horizontal Bars

You can display multiple series as grouped horizontal bars.

```jsx live
function GroupedHorizontalBars() {
  const ThinSolidLine = memo((props: SolidLineProps) => <SolidLine {...props} strokeWidth={1} />);

  return (
    <CartesianChart
      orientation="vertical"
      height={{ base: 280, tablet: 320, desktop: 360 }}
      inset={{ top: 8, bottom: 8, left: 8, right: 8 }}
      series={[
        {
          id: 'actual',
          data: [85, 72, 95, 68, 78, 62],
          color: 'var(--color-accentBoldBlue)',
        },
        {
          id: 'target',
          data: [90, 80, 85, 75, 85, 70],
          color: 'var(--color-fgMuted)',
        },
      ]}
      xAxis={{
        domain: { min: 0, max: 100 },
        showGrid: true,
        GridLineComponent: ThinSolidLine,
        tickLabelFormatter: (value) => `${value}%`,
      }}
      yAxis={{
        scaleType: 'band',
        data: ['Q1 2023', 'Q2 2023', 'Q3 2023', 'Q4 2023', 'Q1 2024', 'Q2 2024'],
      }}
    >
      <XAxis showLine />
      <YAxis position="left" width={70} />
      <BarPlot />
    </CartesianChart>
  );
}
```

### Voter Turnout Chart with Piecewise Gradient

This example shows a horizontal bar chart with piecewise color gradient based on value thresholds: red for low turnout (&lt;50%), gray for average (50-85%), and blue for high turnout (&gt;85%).

```jsx live
function VoterTurnoutChart() {
  const ThinSolidLine = memo((props: SolidLineProps) => <SolidLine {...props} strokeWidth={1} />);

  const voterData = [
    { country: 'Romania (2020)', turnout: 33.2 },
    { country: 'Bulgaria (2024)', turnout: 33.4 },
    { country: 'Albania (2021)', turnout: 46.3 },
    { country: 'United Kingdom (2024)', turnout: 60.0 },
    { country: 'Spain (2023)', turnout: 66.0 },
    { country: 'France (2024)', turnout: 66.7 },
    { country: 'Germany (2021)', turnout: 76.4 },
    { country: 'Sweden (2022)', turnout: 83.8 },
    { country: 'Malta (2022)', turnout: 85.6 },
    { country: 'Turkey (2023)', turnout: 87.0 },
    { country: 'Belgium (2024)', turnout: 88.5 },
  ];

  const turnoutValues = voterData.map((d) => d.turnout);
  const countries = voterData.map((d) => d.country);

  return (
    <VStack gap={4}>
      <Text font="title3">European countries with lowest & highest voter turnout</Text>
      <CartesianChart
        orientation="vertical"
        height={{ base: 400, tablet: 450, desktop: 500 }}
        inset={{ top: 8, bottom: 8, left: 8, right: 8 }}
        series={[
          {
            id: 'low',
            data: [],
            label: 'lowest turnout',
            color: 'var(--color-accentBoldRed)',
            legendShape: 'squircle',
          },
          {
            id: 'avg',
            data: [],
            label: 'average',
            color: 'var(--color-fgMuted)',
            legendShape: 'squircle',
          },
          {
            id: 'high',
            data: [],
            label: 'highest turnout',
            color: 'var(--color-accentBoldBlue)',
            legendShape: 'squircle',
          },
          {
            id: 'turnout',
            data: turnoutValues,
            gradient: {
              axis: 'x',
              // Piecewise gradient: red < 50, gray 50-85, blue > 85
              // Using duplicate stops at thresholds creates hard color transitions
              stops: [
                { offset: 0, color: 'var(--color-accentBoldRed)' },
                { offset: 49.9, color: 'var(--color-accentBoldRed)' },
                { offset: 50, color: 'var(--color-fgMuted)' },
                { offset: 84.9, color: 'var(--color-fgMuted)' },
                { offset: 85, color: 'var(--color-accentBoldBlue)' },
                { offset: 100, color: 'var(--color-accentBoldBlue)' },
              ],
            },
          },
        ]}
        xAxis={{
          domain: { min: 0, max: 100 },
          showGrid: true,
          GridLineComponent: ThinSolidLine,
          tickLabelFormatter: (value) => `${value}%`,
        }}
        yAxis={{
          scaleType: 'band',
          data: countries,
        }}
      >
        <Legend seriesIds={['low', 'avg', 'high']} />
        <XAxis showLine />
        <YAxis position="left" width={140} />
        <BarPlot seriesIds={['turnout']} borderRadius={0} />
      </CartesianChart>
    </VStack>
  );
}
```

### Multi-Segment Progress Bar

This example shows how to create a segmented progress bar using stacked horizontal bars. This is useful for showing proportions like "bought vs sold" or any multi-segment breakdown that sums to 100%.

```jsx live
function MultiSegmentProgressBar() {
  // Data represents percentages that sum to 100
  const bought = 76;
  const sold = 24;

  return (
    <VStack gap={2} style={{ width: '100%' }}>
      <CartesianChart
        orientation="vertical"
        height={40}
        inset={{ top: 0, bottom: 0, left: 0, right: 0 }}
        series={[
          {
            id: 'bought',
            data: [bought],
            label: `${bought}% bought`,
            color: 'var(--color-accentBoldGreen)',
            stackId: 'progress',
            legendShape: 'circle',
          },
          {
            id: 'sold',
            data: [sold],
            label: `${sold}% sold`,
            color: 'var(--color-accentBoldRed)',
            stackId: 'progress',
            legendShape: 'circle',
          },
        ]}
        xAxis={{
          domain: { min: 0, max: 100 },
        }}
        yAxis={{
          scaleType: 'band',
          data: [''],
        }}
      >
        <BarPlot borderRadius={4} />
      </CartesianChart>
      <Legend justifyContent="space-between" />
    </VStack>
  );
}
```

### Multi-Segment Progress with Multiple Rows

You can also display multiple progress bars with different breakdowns.

```jsx live
function MultiRowProgressBars() {
  const data = [
    { category: 'Portfolio A', stocks: 60, bonds: 25, cash: 15 },
    { category: 'Portfolio B', stocks: 45, bonds: 40, cash: 15 },
    { category: 'Portfolio C', stocks: 80, bonds: 15, cash: 5 },
  ];

  return (
    <VStack gap={3} style={{ width: '100%' }}>
      <CartesianChart
        orientation="vertical"
        height={160}
        inset={{ top: 8, bottom: 8, left: 8, right: 8 }}
        series={[
          {
            id: 'stocks',
            data: data.map((d) => d.stocks),
            label: 'Stocks',
            color: 'var(--color-accentBoldBlue)',
            stackId: 'allocation',
            legendShape: 'squircle',
          },
          {
            id: 'bonds',
            data: data.map((d) => d.bonds),
            label: 'Bonds',
            color: 'var(--color-accentBoldGreen)',
            stackId: 'allocation',
            legendShape: 'squircle',
          },
          {
            id: 'cash',
            data: data.map((d) => d.cash),
            label: 'Cash',
            color: 'var(--color-fgMuted)',
            stackId: 'allocation',
            legendShape: 'squircle',
          },
        ]}
        xAxis={{
          domain: { min: 0, max: 100 },
          tickLabelFormatter: (value) => `${value}%`,
        }}
        yAxis={{
          scaleType: 'band',
          data: data.map((d) => d.category),
        }}
      >
        <XAxis showLine />
        <YAxis position="left" width={90} />
        <BarPlot borderRadius={4} />
      </CartesianChart>
      <Legend />
    </VStack>
  );
}
```
