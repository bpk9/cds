PolarChart is a customizable, SVG based component that can be used to display a variety of data in a polar coordinate space. The underlying logic is handled by D3.

## Basics

[PieChart](/components/graphs/PieChart/) and [DonutChart](/components/graphs/DonutChart/) are built on top of PolarChart and have default functionality for your chart.

```jsx live
<HStack gap={4} justifyContent="center">
  <VStack alignItems="center" gap={2}>
    <PieChart
      height={150}
      width={150}
      series={[
        { id: 'a', data: 30, color: 'rgb(var(--blue40))' },
        { id: 'b', data: 40, color: 'rgb(var(--green40))' },
        { id: 'c', data: 30, color: 'rgb(var(--purple40))' },
      ]}
    />
    <Text font="label2" color="fgMuted">
      PieChart
    </Text>
  </VStack>
  <VStack alignItems="center" gap={2}>
    <DonutChart
      height={150}
      width={150}
      innerRadiusRatio={0.6}
      series={[
        { id: 'a', data: 30, color: 'rgb(var(--blue40))' },
        { id: 'b', data: 40, color: 'rgb(var(--green40))' },
        { id: 'c', data: 30, color: 'rgb(var(--purple40))' },
      ]}
    />
    <Text font="label2" color="fgMuted">
      DonutChart
    </Text>
  </VStack>
</HStack>
```

### Series

Series are the data that will be displayed on the chart. Each series must have a defined `id` and `data` (a single number representing the value).

```jsx live
<PolarChart
  height={200}
  series={[
    { id: 'btc', data: 40, label: 'Bitcoin', color: 'rgb(var(--orange40))' },
    { id: 'eth', data: 30, label: 'Ethereum', color: 'rgb(var(--blue40))' },
    { id: 'sol', data: 20, label: 'Solana', color: 'rgb(var(--purple40))' },
    { id: 'other', data: 10, label: 'Other', color: 'rgb(var(--gray40))' },
  ]}
>
  <PiePlot />
</PolarChart>
```

## Angular Axis

The angular axis controls the start and end angles of the chart. By default, it creates a full circle (0° to 360°).

### Custom Range

Use `angularAxis` with `range` to create partial charts.

```jsx live
<HStack gap={4} justifyContent="center">
  <VStack alignItems="center" gap={2}>
    <PolarChart
      height={120}
      width={200}
      angularAxis={{ range: { min: -90, max: 90 } }}
      series={[
        { id: 'a', data: 35, color: 'rgb(var(--green40))' },
        { id: 'b', data: 65, color: 'rgb(var(--gray20))' },
      ]}
    >
      <PiePlot cornerRadius={2} />
    </PolarChart>
    <Text font="label2" color="fgMuted">
      Semicircle (top)
    </Text>
  </VStack>
  <VStack alignItems="center" gap={2}>
    <PolarChart
      height={120}
      width={200}
      angularAxis={{ range: { min: 90, max: 270 } }}
      series={[
        { id: 'a', data: 35, color: 'rgb(var(--green40))' },
        { id: 'b', data: 65, color: 'rgb(var(--gray20))' },
      ]}
    >
      <PiePlot cornerRadius={2} />
    </PolarChart>
    <Text font="label2" color="fgMuted">
      Semicircle (bottom)
    </Text>
  </VStack>
</HStack>
```

### Padding Angle

Use `paddingAngle` to add gaps between slices.

```jsx live
<PolarChart
  height={200}
  radialAxis={{
    range: ({ max }) => ({ min: max - 16, max }),
  }}
  angularAxis={{ paddingAngle: 5 }}
  series={[
    { id: 'a', data: 30, color: 'rgb(var(--blue40))' },
    { id: 'b', data: 40, color: 'rgb(var(--green40))' },
    { id: 'c', data: 30, color: 'rgb(var(--purple40))' },
  ]}
>
  <PiePlot cornerRadius={8} />
</PolarChart>
```

### Multiple Angular Axes

You can define multiple angular axes for different sections of the chart.

```jsx live
<PolarChart
  height={200}
  angularAxis={[
    { id: 'top', range: { min: -45, max: 45 } },
    { id: 'bottom', range: { min: 135, max: 225 } },
  ]}
  radialAxis={{
    range: ({ max }) => ({ min: max - 16, max }),
  }}
  series={[
    { id: 'revenue', data: 30, color: 'rgb(var(--blue40))', angularAxisId: 'top' },
    { id: 'profit', data: 50, color: 'rgb(var(--green40))', angularAxisId: 'top' },
    { id: 'costs', data: 20, color: 'rgb(var(--orange40))', angularAxisId: 'top' },
    { id: 'users', data: 40, color: 'rgb(var(--purple40))', angularAxisId: 'bottom' },
    { id: 'sessions', data: 35, color: 'rgb(var(--yellow40))', angularAxisId: 'bottom' },
    { id: 'conversions', data: 25, color: 'rgb(var(--teal40))', angularAxisId: 'bottom' },
  ]}
>
  <PiePlot angularAxisId="top" cornerRadius={4} />
  <PiePlot angularAxisId="bottom" cornerRadius={4} />
</PolarChart>
```

## Radial Axis

The radial axis controls the inner and outer radii of the chart. By default, it starts from 0 (center) to the full radius.

### Donut

Use `radialAxis` with `range` to create a donut chart with a hollow center.

```jsx live
<PolarChart
  height={200}
  radialAxis={{ range: ({ max }) => ({ min: max * 0.6, max }) }}
  series={[
    { id: 'a', data: 30, color: 'rgb(var(--blue40))' },
    { id: 'b', data: 40, color: 'rgb(var(--green40))' },
    { id: 'c', data: 30, color: 'rgb(var(--purple40))' },
  ]}
>
  <PiePlot cornerRadius={4} />
</PolarChart>
```

### Nested Rings

Use multiple radial axes to create nested rings.

```jsx live
<PolarChart
  height={250}
  radialAxis={[
    { id: 'inner', range: ({ max }) => ({ min: 0, max: max * 0.8 }) },
    { id: 'outer', range: ({ max }) => ({ min: max * 0.85, max }) },
  ]}
  series={[
    { id: 'a', radialAxisId: 'inner', data: 30, label: 'Category A', color: 'rgb(var(--blue40))' },
    {
      id: 'b',
      radialAxisId: 'inner',
      data: 20,
      label: 'Category B',
      color: 'rgb(var(--purple40))',
    },
    { id: 'c', radialAxisId: 'inner', data: 15, label: 'Category C', color: 'rgb(var(--pink50))' },
    {
      id: 'd',
      radialAxisId: 'inner',
      data: 10,
      label: 'Category D',
      color: 'rgb(var(--orange40))',
    },
    {
      id: 'e',
      radialAxisId: 'inner',
      data: 15,
      label: 'Category E',
      color: 'rgb(var(--yellow40))',
    },
    { id: 'f', radialAxisId: 'inner', data: 10, label: 'Category F', color: 'rgb(var(--green40))' },
    {
      id: 'aa',
      radialAxisId: 'outer',
      data: 20,
      label: 'Category AA',
      color: 'rgb(var(--blue30))',
    },
    {
      id: 'ab',
      radialAxisId: 'outer',
      data: 10,
      label: 'Category AB',
      color: 'rgb(var(--blue50))',
    },
    {
      id: 'ba',
      radialAxisId: 'outer',
      data: 15,
      label: 'Category BA',
      color: 'rgb(var(--purple30))',
    },
    {
      id: 'bb',
      radialAxisId: 'outer',
      data: 5,
      label: 'Category BA',
      color: 'rgb(var(--purple50))',
    },
    {
      id: 'ca',
      radialAxisId: 'outer',
      data: 12,
      label: 'Category CA',
      color: 'rgb(var(--pink40))',
    },
    { id: 'cb', radialAxisId: 'outer', data: 3, label: 'Category CB', color: 'rgb(var(--pink60))' },
    {
      id: 'da',
      radialAxisId: 'outer',
      data: 4,
      label: 'Category DA',
      color: 'rgb(var(--orange30))',
    },
    {
      id: 'db',
      radialAxisId: 'outer',
      data: 6,
      label: 'Category DB',
      color: 'rgb(var(--orange50))',
    },
    {
      id: 'ea',
      radialAxisId: 'outer',
      data: 15,
      label: 'Category E',
      color: 'rgb(var(--yellow40))',
    },
    {
      id: 'fa',
      radialAxisId: 'outer',
      data: 3,
      label: 'Category FA',
      color: 'rgb(var(--green30))',
    },
    {
      id: 'fb',
      radialAxisId: 'outer',
      data: 7,
      label: 'Category FB',
      color: 'rgb(var(--green50))',
    },
  ]}
>
  <PiePlot radialAxisId="inner" strokeWidth={0} />
  <PiePlot radialAxisId="outer" strokeWidth={0} />
</PolarChart>
```

## Composed Examples

### Center Label

Add custom content to the center of donut-style charts using SVG text elements positioned via `usePolarChartContext`.

```jsx live
function DonutWithCenterLabel() {
  const series = [
    { id: 'a', data: 30, label: 'Category A', color: 'rgb(var(--blue40))' },
    { id: 'b', data: 20, label: 'Category B', color: 'rgb(var(--purple40))' },
    { id: 'c', data: 15, label: 'Category C', color: 'rgb(var(--pink50))' },
    { id: 'd', data: 10, label: 'Category D', color: 'rgb(var(--orange40))' },
    { id: 'e', data: 15, label: 'Category E', color: 'rgb(var(--yellow40))' },
    { id: 'f', data: 10, label: 'Category F', color: 'rgb(var(--green40))' },
  ];

  const total = series.reduce((sum, s) => sum + s.data, 0);

  const Label = () => {
    const { drawingArea } = useChartContext();

    if (!drawingArea.width) return;

    const centerX = drawingArea.x + drawingArea.width / 2;
    const centerY = drawingArea.y + drawingArea.height / 2;

    return (
      <>
        <ChartText x={centerX} y={centerY} font="label2" verticalAlignment="bottom">
          Total
        </ChartText>
        <ChartText
          x={centerX}
          y={centerY}
          font="headline"
          verticalAlignment="top"
          color="var(--color-fg)"
        >
          ${(total * 100).toLocaleString()}
        </ChartText>
      </>
    );
  };

  return (
    <DonutChart
      height={200}
      innerRadiusRatio={0.65}
      stroke="var(--color-bg)"
      strokeWidth={2}
      series={series}
    >
      <Label />
    </DonutChart>
  );
}
```

### Interactive Nested Chart

You can create a nested polar chart where interaction at one level highlights related segments at another level.
In this example, hovering an inner segment (e.g., "A") highlights it and all its outer children ("AA", "AB").
Hovering an outer segment (e.g., "AA") highlights it and its parent ("A"), but not siblings ("AB").

This is achieved by creating custom Arc components that override the default highlighting behavior.

```jsx live
function InteractiveNestedChart() {
  // Get parent for an outer series (e.g., 'aa' -> 'a')
  const getParent = (seriesId) => seriesId?.[0];

  // Custom Arc that renders path directly to bypass Arc's internal dimming logic
  // The Arc component has built-in highlighting that overrides fillOpacity,
  // so we render the SVG path directly for full control
  const CustomArc = memo(({ isRelated, ...props }) => {
    const highlightContext = useHighlightContext();
    const highlightedId = highlightContext?.highlightedItem?.seriesId;
    const { drawingArea } = usePolarChartContext();

    const centerX = drawingArea.x + drawingArea.width / 2;
    const centerY = drawingArea.y + drawingArea.height / 2;

    const path = getArcPath({
      startAngle: props.startAngle,
      endAngle: props.endAngle,
      innerRadius: props.innerRadius,
      outerRadius: props.outerRadius,
      paddingAngle: props.paddingAngle,
    });

    // Determine if this arc should be dimmed
    const shouldDim = highlightedId && !isRelated;

    return (
      <g transform={`translate(${centerX}, ${centerY})`}>
        <path
          d={path}
          fill={props.fill}
          fillOpacity={shouldDim ? 0.3 : 1}
          onMouseEnter={props.onMouseEnter}
          onMouseLeave={props.onMouseLeave}
          style={{ transition: 'fill-opacity 0.2s ease-out' }}
        />
      </g>
    );
  });

  // Custom Arc for inner ring - highlighted when:
  // - This segment is hovered, OR
  // - Any of its children (outer segments) is hovered
  const InnerArc = (props) => {
    const highlightContext = useHighlightContext();
    const highlightedId = highlightContext?.highlightedItem?.seriesId;

    // Check if this inner arc should be highlighted
    const isExactMatch = props.seriesId === highlightedId;
    const isParentOfHighlighted = getParent(highlightedId) === props.seriesId;
    const isRelated = isExactMatch || isParentOfHighlighted;

    return <CustomArc {...props} isRelated={isRelated} />;
  };

  // Custom Arc for outer ring - highlighted when:
  // - This segment is hovered, OR
  // - Its parent (inner segment) is hovered
  // NOT highlighted when a sibling is hovered
  const OuterArc = (props) => {
    const highlightContext = useHighlightContext();
    const highlightedId = highlightContext?.highlightedItem?.seriesId;

    // Check if this outer arc should be highlighted
    const isExactMatch = props.seriesId === highlightedId;
    const myParent = getParent(props.seriesId);
    const isHighlightedMyParent = myParent === highlightedId;
    const isRelated = isExactMatch || isHighlightedMyParent;

    return <CustomArc {...props} isRelated={isRelated} />;
  };

  return (
    <PolarChart
      enableHighlighting
      height={250}
      radialAxis={[
        { id: 'inner', range: ({ max }) => ({ min: 0, max: max * 0.8 }) },
        { id: 'outer', range: ({ max }) => ({ min: max * 0.85, max }) },
      ]}
      legend={<Legend seriesIds={['a', 'b', 'c', 'd', 'e', 'f']} />}
      legendPosition="bottom"
      series={[
        {
          id: 'a',
          radialAxisId: 'inner',
          data: 30,
          label: 'Category A',
          color: 'rgb(var(--blue40))',
        },
        {
          id: 'b',
          radialAxisId: 'inner',
          data: 20,
          label: 'Category B',
          color: 'rgb(var(--purple40))',
        },
        {
          id: 'c',
          radialAxisId: 'inner',
          data: 15,
          label: 'Category C',
          color: 'rgb(var(--pink50))',
        },
        {
          id: 'd',
          radialAxisId: 'inner',
          data: 10,
          label: 'Category D',
          color: 'rgb(var(--orange40))',
        },
        {
          id: 'e',
          radialAxisId: 'inner',
          data: 15,
          label: 'Category E',
          color: 'rgb(var(--yellow40))',
        },
        {
          id: 'f',
          radialAxisId: 'inner',
          data: 10,
          label: 'Category F',
          color: 'rgb(var(--green40))',
        },
        {
          id: 'aa',
          radialAxisId: 'outer',
          data: 20,
          label: 'Category AA',
          color: 'rgb(var(--blue30))',
        },
        {
          id: 'ab',
          radialAxisId: 'outer',
          data: 10,
          label: 'Category AB',
          color: 'rgb(var(--blue50))',
        },
        {
          id: 'ba',
          radialAxisId: 'outer',
          data: 15,
          label: 'Category BA',
          color: 'rgb(var(--purple30))',
        },
        {
          id: 'bb',
          radialAxisId: 'outer',
          data: 5,
          label: 'Category BB',
          color: 'rgb(var(--purple50))',
        },
        {
          id: 'ca',
          radialAxisId: 'outer',
          data: 12,
          label: 'Category CA',
          color: 'rgb(var(--pink40))',
        },
        {
          id: 'cb',
          radialAxisId: 'outer',
          data: 3,
          label: 'Category CB',
          color: 'rgb(var(--pink60))',
        },
        {
          id: 'da',
          radialAxisId: 'outer',
          data: 4,
          label: 'Category DA',
          color: 'rgb(var(--orange30))',
        },
        {
          id: 'db',
          radialAxisId: 'outer',
          data: 6,
          label: 'Category DB',
          color: 'rgb(var(--orange50))',
        },
        {
          id: 'ea',
          radialAxisId: 'outer',
          data: 15,
          label: 'Category EA',
          color: 'rgb(var(--yellow40))',
        },
        {
          id: 'fa',
          radialAxisId: 'outer',
          data: 3,
          label: 'Category FA',
          color: 'rgb(var(--green30))',
        },
        {
          id: 'fb',
          radialAxisId: 'outer',
          data: 7,
          label: 'Category FB',
          color: 'rgb(var(--green50))',
        },
      ]}
    >
      <PiePlot radialAxisId="inner" strokeWidth={0} ArcComponent={InnerArc} />
      <PiePlot radialAxisId="outer" strokeWidth={0} ArcComponent={OuterArc} />
      <ChartTooltip />
    </PolarChart>
  );
}
```

### Segmented Progress Ring

A progress ring with segmented sections and clipped progress indicator.

```jsx live
function SegmentedProgressRing() {
  const innerRadiusRatio = 0.75;
  const angleEachSideGap = (45 / 4) * 3;
  const startAngleDegrees = angleEachSideGap - 180;
  const endAngleDegrees = 180 - angleEachSideGap;
  const angleGapDegrees = 5;
  const totalGapDegrees = angleGapDegrees * 2;
  const gapBetweenDegrees = totalGapDegrees / 3;
  const sectionLengthDegrees = (endAngleDegrees - startAngleDegrees) / 3 - gapBetweenDegrees;

  const firstSectionEnd = startAngleDegrees + sectionLengthDegrees;
  const secondSectionStart = firstSectionEnd + gapBetweenDegrees;
  const secondSectionEnd = secondSectionStart + sectionLengthDegrees;
  const thirdSectionStart = secondSectionEnd + gapBetweenDegrees;
  const thirdSectionEnd = thirdSectionStart + sectionLengthDegrees;
  const progressAngle = -45;

  const BackgroundArcs = memo(() => {
    const { drawingArea } = usePolarChartContext();

    const { innerRadius, outerRadius } = useMemo(() => {
      const r = Math.min(drawingArea.width, drawingArea.height) / 2;
      return {
        innerRadius: r * innerRadiusRatio,
        outerRadius: r,
      };
    }, [drawingArea]);

    const sections = useMemo(
      () => [
        {
          startAngle: (startAngleDegrees * Math.PI) / 180,
          endAngle: (firstSectionEnd * Math.PI) / 180,
        },
        {
          startAngle: (secondSectionStart * Math.PI) / 180,
          endAngle: (secondSectionEnd * Math.PI) / 180,
        },
        {
          startAngle: (thirdSectionStart * Math.PI) / 180,
          endAngle: (thirdSectionEnd * Math.PI) / 180,
        },
      ],
      [],
    );

    return (
      <>
        {sections.map((section, i) => (
          <Arc
            key={i}
            animate={false}
            cornerRadius={100}
            endAngle={section.endAngle}
            fill="var(--color-fgMuted)"
            fillOpacity={0.25}
            innerRadius={innerRadius}
            outerRadius={outerRadius}
            paddingAngle={0}
            startAngle={section.startAngle}
          />
        ))}
      </>
    );
  });

  const ClippedProgress = memo(() => {
    const { drawingArea } = usePolarChartContext();

    const clipPathId = useMemo(() => {
      return `rewards-clip-${Math.random().toString(36).substr(2, 9)}`;
    }, []);

    const clipPath = useMemo(() => {
      const r = Math.min(drawingArea.width, drawingArea.height) / 2;
      const innerRadius = r * innerRadiusRatio;
      const outerRadius = r;

      const sections = [
        {
          startAngle: (startAngleDegrees * Math.PI) / 180,
          endAngle: (firstSectionEnd * Math.PI) / 180,
        },
        {
          startAngle: (secondSectionStart * Math.PI) / 180,
          endAngle: (secondSectionEnd * Math.PI) / 180,
        },
        {
          startAngle: (thirdSectionStart * Math.PI) / 180,
          endAngle: (thirdSectionEnd * Math.PI) / 180,
        },
      ];

      return sections
        .map((section) =>
          getArcPath({
            startAngle: section.startAngle,
            endAngle: section.endAngle,
            innerRadius,
            outerRadius,
            cornerRadius: 100,
          }),
        )
        .join(' ');
    }, [drawingArea]);

    const centerX = drawingArea.x + drawingArea.width / 2;
    const centerY = drawingArea.y + drawingArea.height / 2;

    return (
      <>
        <defs>
          <clipPath id={clipPathId}>
            <path d={clipPath} transform={`translate(${centerX}, ${centerY})`} />
          </clipPath>
        </defs>
        <g clipPath={`url(#${clipPathId})`}>
          <PiePlot cornerRadius={100} strokeWidth={0} />
        </g>
      </>
    );
  });

  return (
    <PolarChart
      animate
      angularAxis={{ range: { min: startAngleDegrees, max: progressAngle } }}
      height={200}
      inset={0}
      radialAxis={{ range: ({ max }) => ({ min: innerRadiusRatio * max, max }) }}
      series={[{ id: 'progress', data: 100, color: 'var(--color-fg)' }]}
      width={200}
    >
      <BackgroundArcs />
      <ClippedProgress />
    </PolarChart>
  );
}
```
