diff --git a/src/handlers/gestures/GestureDetector.tsx b/src/handlers/gestures/GestureDetector.tsx
index 45d927c230a86a7713d097f19e97da9c32563e2d..06c8d1d441957f29f899af5efd533cab25dd690d 100644
--- a/src/handlers/gestures/GestureDetector.tsx
+++ b/src/handlers/gestures/GestureDetector.tsx
@@ -256,8 +256,29 @@ function updateHandlers(
 ) {
   gestureConfig.prepare();
 
+  /* Patch added to fix performance regression due to SharedValue reads. As 
+  * per this discussion https://github.com/software-mansion/react-native-gesture-handler/commit/1217039146ddcae6796820b5ecf19d1ff51af837#r143406410
+  *
+  * Remove patch if this change
+  * https://github.com/software-mansion/react-native-gesture-handler/pull/2957
+  * has landed on the version you upgrade to.
+  */
+  // if amount of gesture configs changes, we need to update the callbacks in shared value
+  let shouldUpdateSharedValueIfUsed =
+    preparedGesture.config.length !== gesture.length;
+  
   for (let i = 0; i < gesture.length; i++) {
     const handler = preparedGesture.config[i];
+
+    // if the gestureId is different (gesture isn't wrapped with useMemo or its dependencies changed),
+    // we need to update the shared value, assuming the gesture runs on UI thread or the thread changed
+    if (
+      handler.handlers.gestureId !== gesture[i].handlers.gestureId &&
+      (gesture[i].shouldUseReanimated || handler.shouldUseReanimated)
+    ) {
+      shouldUpdateSharedValueIfUsed = true;
+    }
+    
     checkGestureCallbacksForWorklets(handler);
 
     // only update handlerTag when it's actually different, it may be the same
@@ -301,34 +322,13 @@ function updateHandlers(
     }
 
     if (preparedGesture.animatedHandlers) {
-      const previousHandlersValue =
-        preparedGesture.animatedHandlers.value ?? [];
-      const newHandlersValue = preparedGesture.config
-        .filter((g) => g.shouldUseReanimated) // ignore gestures that shouldn't run on UI
-        .map((g) => g.handlers) as unknown as HandlerCallbacks<
-        Record<string, unknown>
-      >[];
-
-      // if amount of gesture configs changes, we need to update the callbacks in shared value
-      let shouldUpdateSharedValue =
-        previousHandlersValue.length !== newHandlersValue.length;
-
-      if (!shouldUpdateSharedValue) {
-        // if the amount is the same, we need to check if any of the configs inside has changed
-        for (let i = 0; i < newHandlersValue.length; i++) {
-          if (
-            // we can use the `gestureId` prop as it's unique for every config instance
-            newHandlersValue[i].gestureId !== previousHandlersValue[i].gestureId
-          ) {
-            shouldUpdateSharedValue = true;
-            break;
-          }
-        }
-      }
-
-      if (shouldUpdateSharedValue) {
-        preparedGesture.animatedHandlers.value = newHandlersValue;
-      }
+      if (shouldUpdateSharedValueIfUsed) {
+        preparedGesture.animatedHandlers.value = preparedGesture.config
+          .filter((g) => g.shouldUseReanimated) // ignore gestures that shouldn't run on UI
+          .map((g) => g.handlers) as unknown as HandlerCallbacks<
+          Record<string, unknown>
+        >[];
+      }        
     }
 
     scheduleFlushOperations();
